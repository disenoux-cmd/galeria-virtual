<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>La Galería de la Propaganda</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;700&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            font-family: 'Montserrat', sans-serif;
            color: #f0f0f0;
        }

        #blocker {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            text-align: center;
            transition: opacity 0.5s;
        }

        #instructions {
            width: 600px;
            max-width: 90%;
            cursor: pointer;
        }

        h1 {
            font-weight: 300;
            letter-spacing: 5px;
            text-transform: uppercase;
            margin-bottom: 10px;
            color: #ffffff;
            border-bottom: 1px solid #444;
            padding-bottom: 20px;
        }

        p {
            font-size: 16px;
            line-height: 1.6;
            color: #ccc;
        }

        .btn {
            background: transparent;
            border: 1px solid #fff;
            color: #fff;
            padding: 15px 30px;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 2px;
            cursor: pointer;
            margin-top: 20px;
            transition: all 0.3s;
        }

        .btn:hover {
            background: #fff;
            color: #000;
        }

        /* Crosshair */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 10px;
            height: 10px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 5;
            mix-blend-mode: difference;
        }

        /* Interaction Prompt */
        #interact-msg {
            position: absolute;
            top: 60%;
            left: 50%;
            transform: translateX(-50%);
            font-size: 14px;
            color: #fff;
            background: rgba(0,0,0,0.5);
            padding: 5px 10px;
            border-radius: 4px;
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: none;
            z-index: 5;
        }

        /* Modal for Hotspots */
        #info-modal {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 500px;
            max-width: 90%;
            background: rgba(20, 20, 20, 0.95);
            border: 1px solid #444;
            padding: 40px;
            z-index: 20;
            box-shadow: 0 0 30px rgba(0,0,0,0.8);
            text-align: left;
        }

        #info-modal h2 {
            margin-top: 0;
            color: #ffcc00; /* Accent color */
            font-size: 20px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        #info-modal p {
            color: #ddd;
        }

        #info-modal .close-btn {
            position: absolute;
            top: 10px;
            right: 15px;
            color: #666;
            font-size: 24px;
            cursor: pointer;
            background: none;
            border: none;
        }
        
        #info-modal .close-btn:hover {
            color: #fff;
        }

        /* Final Selection UI */
        #final-ui {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 10, 0.95);
            z-index: 30;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
        }

        .card-container {
            display: flex;
            gap: 20px;
            margin-top: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .choice-card {
            background: #222;
            border: 1px solid #444;
            padding: 20px;
            width: 250px;
            cursor: pointer;
            transition: transform 0.2s, border-color 0.2s;
        }

        .choice-card:hover {
            transform: translateY(-5px);
            border-color: #ffcc00;
        }

        .choice-card h3 {
            color: #fff;
            margin-bottom: 10px;
        }

        /* Room Labels */
        .label {
            color: #fff;
            font-family: sans-serif;
            padding: 2px;
            background: rgba(0, 0, 0, 0.6);
            font-size: 20px; 
            text-align: center;
        }
    </style>
    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
</head>
<body>

    <!-- HUD Elements -->
    <div id="crosshair"></div>
    <div id="interact-msg">Click para interactuar (+)</div>

    <!-- Intro Screen -->
    <div id="blocker">
        <div id="instructions">
            <h1>La Galería de la Propaganda</h1>
            <p>
                Bienvenido, detective. La propaganda no busca solo informar: busca influir en tus emociones y acciones.
                <br><br>
                <strong>Misión:</strong>
                <br>1. Explora las 3 salas (Guerra, Comercial, Política).
                <br>2. Interactúa con los puntos de análisis (+).
                <br>3. Regresa al lobby para elegir una pieza final.
            </p>
            <p style="font-size: 12px; color: #888; margin-top: 30px;">
                Controles: W, A, S, D para moverte | Ratón para mirar | Click para interactuar | ESC para pausar
            </p>
            <button class="btn">Comenzar Recorrido</button>
        </div>
    </div>

    <!-- Info Modal -->
    <div id="info-modal">
        <button class="close-btn">&times;</button>
        <h2 id="modal-title">Título</h2>
        <div id="modal-content">Contenido...</div>
        <button class="btn" id="modal-close-main" style="margin-top: 20px; padding: 10px 20px; width: 100%;">Cerrar</button>
    </div>

    <!-- Final Choice UI -->
    <div id="final-ui">
        <h1>Análisis Final</h1>
        <p>Has completado el recorrido. ¿Qué estrategia de persuasión te pareció más impactante?</p>
        <p>Elige UNA pieza para analizar en tu hoja de trabajo (RED 2.6):</p>
        
        <div class="card-container">
            <div class="choice-card" onclick="selectFinal('Rosie')">
                <h3>Rosie the Riveter</h3>
                <p>Propaganda de Guerra</p>
                <p style="font-size:12px; color:#888;">Patriotismo y Deber</p>
            </div>
            <div class="choice-card" onclick="selectFinal('Cola')">
                <h3>Destapa la Felicidad</h3>
                <p>Propaganda Comercial</p>
                <p style="font-size:12px; color:#888;">Asociación Emocional</p>
            </div>
            <div class="choice-card" onclick="selectFinal('Politica')">
                <h3>Candidato Arturo</h3>
                <p>Propaganda Política</p>
                <p style="font-size:12px; color:#888;">Miedo y Polarización</p>
            </div>
        </div>
    </div>

    <script>
        // --- CONFIGURACIÓN DE NOMBRES DE IMAGEN ---
        // Asegúrate de que tus archivos se llamen así y estén junto al HTML
        const IMG_FILES = {
            rosie: 'rosie.png',
            coca: 'coca.png',
            politica: 'politica.png'
        };

        // --- VARIABLES GLOBALES ---
        let camera, scene, renderer, controls;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let raycaster;
        let prevTime = performance.now();
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let exitMesh; 
        
        // Elementos interactivos
        const hotspots = [];
        let isModalOpen = false;
        let visitedRooms = { 1: false, 2: false, 3: false };
        let exitUnlocked = false;
        
        // Loader de texturas
        const textureLoader = new THREE.TextureLoader();

        // DOM Elements
        const blocker = document.getElementById('blocker');
        const instructions = document.getElementById('instructions');
        const interactMsg = document.getElementById('interact-msg');
        const infoModal = document.getElementById('info-modal');
        const modalTitle = document.getElementById('modal-title');
        const modalContent = document.getElementById('modal-content');
        const closeBtn = document.querySelector('.close-btn');
        const closeBtnMain = document.getElementById('modal-close-main');
        const startBtn = document.querySelector('#instructions .btn');
        const finalUI = document.getElementById('final-ui');

        // --- INICIALIZACIÓN ---
        init();
        animate();

        function init() {
            // Escena y Cámara
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);
            scene.fog = new THREE.Fog(0x111111, 0, 40);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.y = 1.6; // Altura de los ojos

            // Iluminación
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5); // Luz tenue
            scene.add(ambientLight);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // Controles
            controls = new THREE.PointerLockControls(camera, document.body);

            // Eventos de bloqueo de puntero
            startBtn.addEventListener('click', function () {
                controls.lock();
            });

            controls.addEventListener('lock', function () {
                if(!isModalOpen && !exitUnlocked) {
                    instructions.style.display = 'none';
                    blocker.style.display = 'none';
                }
            });

            controls.addEventListener('unlock', function () {
                if (!isModalOpen && !exitUnlocked) {
                    blocker.style.display = 'flex';
                    instructions.style.display = '';
                }
            });

            scene.add(controls.getObject());

            // Teclado
            const onKeyDown = function (event) {
                switch (event.code) {
                    case 'ArrowUp':
                    case 'KeyW': moveForward = true; break;
                    case 'ArrowLeft':
                    case 'KeyA': moveLeft = true; break;
                    case 'ArrowDown':
                    case 'KeyS': moveBackward = true; break;
                    case 'ArrowRight':
                    case 'KeyD': moveRight = true; break;
                }
            };

            const onKeyUp = function (event) {
                switch (event.code) {
                    case 'ArrowUp':
                    case 'KeyW': moveForward = false; break;
                    case 'ArrowLeft':
                    case 'KeyA': moveLeft = false; break;
                    case 'ArrowDown':
                    case 'KeyS': moveBackward = false; break;
                    case 'ArrowRight':
                    case 'KeyD': moveRight = false; break;
                }
            };

            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            window.addEventListener('resize', onWindowResize);

            // Raycaster para interacción
            raycaster = new THREE.Raycaster();

            // Construcción del Mundo
            buildGallery();
            
            // Listeners para UI
            document.addEventListener('mousedown', onDocumentMouseDown);
            closeBtn.addEventListener('click', closeModal);
            closeBtnMain.addEventListener('click', closeModal);
        }

        // --- CONSTRUCCIÓN DEL MUSEO ---
        function buildGallery() {
            // Materiales comunes
            const floorMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.8 });
            const wallMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 1 });
            const ceilingMat = new THREE.MeshBasicMaterial({ color: 0x050505 });

            // 1. Suelo
            const floorGeometry = new THREE.PlaneGeometry(60, 60);
            const floor = new THREE.Mesh(floorGeometry, floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            // 2. Techo
            const ceiling = new THREE.Mesh(floorGeometry, ceilingMat);
            ceiling.position.y = 6;
            ceiling.rotation.x = Math.PI / 2;
            scene.add(ceiling);

            // 3. Paredes
            const wallGeo = new THREE.BoxGeometry(1, 6, 20); 
            
            // Paredes Lobby
            createWall(0, 3, -10, 20, 6, 1, wallMat); // Frente
            createWall(0, 3, 10, 20, 6, 1, wallMat);  // Atras
            createWall(-10, 3, 0, 1, 6, 20, wallMat); // Izquierda
            createWall(10, 3, 0, 1, 6, 20, wallMat);  // Derecha

            // --- CONFIGURACIÓN DE ARTE CON IMÁGENES ---

            // SALA 1 (Izquierda) - Rosie
            // Intenta cargar imagen, si falla usa el generador
            createArtWithFallback(
                IMG_FILES.rosie, 
                { text: "We Can Do It!", bg: "#FFCC00", fg: "#003366", type: 'Rosie' },
                new THREE.Vector3(-9.4, 2, -5), 
                Math.PI / 2, 
                1,
                { w: 2.2, h: 3.0 } // Rosie es tipo poster vertical
            );
            
            // Hotspots Rosie
            createHotspot(new THREE.Vector3(-9, 2.5, -5.5), "El Músculo", "Esta mujer no es frágil: es fuerte. El gesto del brazo flexionado se convirtió en un símbolo universal de poder femenino.", 1);
            createHotspot(new THREE.Vector3(-9, 3.2, -5), "El Lema", "El uso de 'We' (Nosotras) crea unidad. No dice 'You can do it', dice 'NOSOTRAS podemos', implicando solidaridad.", 1);
            createHotspot(new THREE.Vector3(-9, 1.5, -4.5), "Contexto (IEEAS)", "<b>Intención:</b> Reclutar mano de obra femenina en fábricas.<br><b>Emoción:</b> Orgullo y capacidad.<br><b>Contexto:</b> Segunda Guerra Mundial.", 1);

            // SALA 2 (Frente) - Coca Cola
            createArtWithFallback(
                IMG_FILES.coca,
                { text: "DESTAPA LA FELICIDAD", bg: "#FFFFFF", fg: "#CC0000", type: 'Cola' },
                new THREE.Vector3(0, 2, -9.4), 
                0, 
                2,
                { w: 2.0, h: 3.2 } // Formato celular alto
            );

            // Hotspots Cola
            createHotspot(new THREE.Vector3(-0.8, 2.5, -9), "Fiesta y Confeti", "La imagen muestra celebración y amigos. No te venden una bebida azucarada, te venden el ser el alma de la fiesta.", 2);
            createHotspot(new THREE.Vector3(0.8, 1.5, -9), "El Brindis", "Todos conectan sus botellas en el centro. El producto es el nexo de unión que hace posible la amistad.", 2);
            createHotspot(new THREE.Vector3(0, 1, -9), "Contexto", "<b>Intención:</b> Vender estilo de vida.<br><b>Técnica:</b> Transferencia (asociar el producto con diversión social).", 2);

            // SALA 3 (Derecha) - Política (Arturo)
            createArtWithFallback(
                IMG_FILES.politica,
                { text: "¡NO DEJES QUE ARTURO DESTRUYA TU FUTURO!", bg: "#110000", fg: "#FF0000", type: 'Politica' },
                new THREE.Vector3(9.4, 2, 5), 
                -Math.PI / 2, 
                3,
                { w: 2.2, h: 3.2 } // Poster vertical
            );

            // Hotspots Politica
            createHotspot(new THREE.Vector3(9, 3, 5), "¡DESTRUYA TU FUTURO!", "El texto en mayúsculas y palabras alarmistas ('Peligro', 'Arruinarán') buscan paralizar el pensamiento racional mediante el miedo.", 3);
            createHotspot(new THREE.Vector3(9, 2, 5.5), "El Rostro de Arturo", "La foto en blanco y negro, granulada y seria, está editada para que el candidato parezca siniestro o amenazante.", 3);
            createHotspot(new THREE.Vector3(9, 1.2, 4.5), "Contexto", "<b>Intención:</b> Disuadir el voto hacia Arturo.<br><b>Emoción:</b> Miedo a la pérdida económica.<br><b>Técnica:</b> Campaña de ataque.", 3);

            // --- SEÑALIZACIÓN ---
            createSign(new THREE.Vector3(-8, 3.5, 0), Math.PI/2, "SALA 1: GUERRA");
            createSign(new THREE.Vector3(0, 3.5, -8), 0, "SALA 2: COMERCIAL");
            createSign(new THREE.Vector3(8, 3.5, 0), -Math.PI/2, "SALA 3: POLÍTICA");

            // Exit Door (Oculta inicialmente)
            createExitDoor();
        }

        function createWall(x, y, z, w, h, d, mat) {
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), mat);
            mesh.position.set(x, y, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);
        }

        // Función inteligente: Intenta cargar imagen, si falla usa canvas
        function createArtWithFallback(imagePath, fallbackData, pos, rotY, roomId, size) {
            // 1. Crear Marco
            const frameGeo = new THREE.BoxGeometry(size.w + 0.2, size.h + 0.2, 0.1);
            const frameMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
            const frame = new THREE.Mesh(frameGeo, frameMat);
            frame.position.copy(pos);
            frame.rotation.y = rotY;
            scene.add(frame);

            // 2. Geometría del Arte
            const artGeo = new THREE.PlaneGeometry(size.w, size.h);
            
            // 3. Intentar cargar textura
            textureLoader.load(
                imagePath,
                // Success
                function(texture) {
                    const artMat = new THREE.MeshBasicMaterial({ map: texture });
                    const art = new THREE.Mesh(artGeo, artMat);
                    finishArtSetup(art, pos, rotY);
                },
                // Progress
                undefined,
                // Error (Cargar fallback)
                function(err) {
                    console.warn("No se encontró la imagen: " + imagePath + ". Usando versión generada.");
                    const fallbackTex = createTextTexture(fallbackData.text, fallbackData.bg, fallbackData.fg, fallbackData.type);
                    const artMat = new THREE.MeshBasicMaterial({ map: fallbackTex });
                    const art = new THREE.Mesh(artGeo, artMat);
                    finishArtSetup(art, pos, rotY);
                }
            );

            // Función auxiliar para posicionar y añadir luz
            function finishArtSetup(mesh, pos, rotY) {
                mesh.position.copy(pos);
                mesh.rotation.y = rotY;
                // Offset para evitar z-fighting
                const offset = new THREE.Vector3(0, 0, 0.06);
                offset.applyAxisAngle(new THREE.Vector3(0, 1, 0), rotY);
                mesh.position.add(offset);
                scene.add(mesh);

                // Luz Spotlight específica para esta obra
                const spotLight = new THREE.SpotLight(0xffffff, 2);
                
                // Calcular posición de luz relativa
                if(rotY === 0) spotLight.position.set(pos.x, 5, pos.z + 4); // Frente
                else if (rotY > 0) spotLight.position.set(pos.x + 3, 5, pos.z); // Izquierda
                else spotLight.position.set(pos.x - 3, 5, pos.z); // Derecha

                spotLight.target = mesh;
                spotLight.angle = 0.4;
                spotLight.penumbra = 0.5;
                spotLight.castShadow = true;
                scene.add(spotLight);
            }
        }

        // Generador de texturas de respaldo (si no hay imágenes)
        function createTextTexture(text, bgColor, fgColor, type) {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 700; 

            const ctx = canvas.getContext('2d');
            
            // Fondo
            ctx.fillStyle = bgColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Gráficos simples según tipo
            if(type === 'Rosie') {
                ctx.fillStyle = '#4488ff'; // Camisa
                ctx.fillRect(100, 300, 300, 400);
                ctx.fillStyle = '#dd3333'; // Bandana
                ctx.beginPath(); ctx.arc(256, 200, 120, 0, Math.PI, true); ctx.fill();
            } else if (type === 'Politica') {
                // Estilo agresivo / sucio
                ctx.fillStyle = '#220000';
                for(let i=0; i<50; i++) {
                   ctx.fillRect(Math.random()*512, Math.random()*700, 512, 2);
                }
                // Cara abstracta
                ctx.fillStyle = '#333';
                ctx.beginPath(); ctx.arc(256, 450, 150, 0, Math.PI*2); ctx.fill();
            }

            // Texto
            ctx.font = 'bold 40px Arial';
            ctx.fillStyle = fgColor;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // Wrap text
            const words = text.split(' ');
            let line = '';
            let y = 100;
            if(type === 'Politica') y = 150;
            if(type === 'Cola') y = 200;

            for(let n = 0; n < words.length; n++) {
                const testLine = line + words[n] + ' ';
                const metrics = ctx.measureText(testLine);
                if (metrics.width > 400 && n > 0) {
                    ctx.fillText(line, 256, y);
                    line = words[n] + ' ';
                    y += 50;
                } else {
                    line = testLine;
                }
            }
            ctx.fillText(line, 256, y);

            return new THREE.CanvasTexture(canvas);
        }

        function createHotspot(pos, title, desc, roomId) {
            const geometry = new THREE.SphereGeometry(0.15, 16, 16);
            const material = new THREE.MeshBasicMaterial({ color: 0x00ffcc });
            const sphere = new THREE.Mesh(geometry, material);
            sphere.position.copy(pos);
            sphere.userData = { 
                type: 'hotspot', 
                title: title, 
                desc: desc,
                roomId: roomId 
            };
            
            sphere.userData.baseScale = 1;
            scene.add(sphere);
            hotspots.push(sphere);
        }

        function createSign(pos, rotY, text) {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.fillRect(0,0,512,128);
            ctx.font = 'bold 40px Arial';
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 256, 64);
            
            const tex = new THREE.CanvasTexture(canvas);
            const mesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 0.5), new THREE.MeshBasicMaterial({map: tex, transparent: true}));
            mesh.position.copy(pos);
            mesh.rotation.y = rotY;
            scene.add(mesh);
        }

        function createExitDoor() {
            // Un cubo brillante en el lobby (atrás)
            const geometry = new THREE.BoxGeometry(2, 3, 0.2);
            const material = new THREE.MeshStandardMaterial({ 
                color: 0x00ff00, 
                emissive: 0x003300,
                emissiveIntensity: 0.5
            });
            exitMesh = new THREE.Mesh(geometry, material);
            exitMesh.position.set(0, 1.5, 9); // Parte trasera del lobby
            exitMesh.userData = { type: 'exit' };
            exitMesh.visible = false; // Oculto al inicio
            scene.add(exitMesh);

            // Texto "SALIDA"
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#00ff00';
            ctx.font = 'bold 50px Arial';
            ctx.textAlign = 'center';
            ctx.fillText("SALIDA", 128, 80);
            const tex = new THREE.CanvasTexture(canvas);
            const sign = new THREE.Mesh(new THREE.PlaneGeometry(1, 0.5), new THREE.MeshBasicMaterial({map: tex, transparent:true}));
            sign.position.set(0, 3.2, 9);
            sign.userData = { parentExit: true };
            sign.visible = false;
            exitMesh.userData.sign = sign;
            scene.add(sign);
        }

        // --- LÓGICA DE INTERACCIÓN ---

        function onDocumentMouseDown(event) {
            if (!controls.isLocked) return;

            raycaster.setFromCamera( new THREE.Vector2(0, 0), camera ); // Centro pantalla
            const intersects = raycaster.intersectObjects(scene.children);

            if (intersects.length > 0) {
                const obj = intersects[0].object;
                if (obj.userData.type === 'hotspot') {
                    openModal(obj.userData.title, obj.userData.desc, obj.userData.roomId);
                } else if (obj.userData.type === 'exit' && exitMesh.visible) {
                    showFinalUI();
                }
            }
        }

        function openModal(title, text, roomId) {
            isModalOpen = true;
            controls.unlock();
            modalTitle.innerText = title;
            modalContent.innerHTML = text;
            infoModal.style.display = 'block';

            // Marcar sala como visitada
            visitedRooms[roomId] = true;
            checkAllVisited();
        }

        function closeModal() {
            infoModal.style.display = 'none';
            isModalOpen = false;
            controls.lock();
        }

        function checkAllVisited() {
            if (visitedRooms[1] && visitedRooms[2] && visitedRooms[3]) {
                if (!exitMesh.visible) {
                    exitMesh.visible = true;
                    exitMesh.userData.sign.visible = true;
                    // Notificación
                    const notif = document.createElement('div');
                    notif.innerText = "¡Salida Desbloqueada! Regresa al Lobby.";
                    notif.style.position = 'absolute';
                    notif.style.top = '20%';
                    notif.style.width = '100%';
                    notif.style.textAlign = 'center';
                    notif.style.color = '#00ff00';
                    notif.style.fontSize = '24px';
                    notif.style.fontWeight = 'bold';
                    notif.style.textShadow = '0 0 10px black';
                    notif.style.zIndex = '100';
                    document.body.appendChild(notif);
                    setTimeout(() => notif.remove(), 4000);
                }
            }
        }

        function showFinalUI() {
            exitUnlocked = true;
            controls.unlock();
            blocker.style.display = 'none'; // Ensure main menu doesn't override
            finalUI.style.display = 'flex';
        }

        window.selectFinal = function(choice) {
            alert(`Has elegido: ${choice}. \n\nAhora serás redirigido a la Tabla de Análisis (Simulación: RED 2.6). \n¡Buen trabajo!`);
            location.reload(); // Reset simulation
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now();
            
            if (controls.isLocked) {
                const delta = (time - prevTime) / 1000;

                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize(); // Evitar movimiento rápido en diagonal

                if (moveForward || moveBackward) velocity.z -= direction.z * 40.0 * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * 40.0 * delta;

                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);
                
                // Límites simples del mapa
                const pos = controls.getObject().position;
                if(pos.x < -12) pos.x = -12;
                if(pos.x > 12) pos.x = 12;
                if(pos.z < -12) pos.z = -12;
                if(pos.z > 12) pos.z = 12;

                // Raycasting para detectar interacción
                raycaster.setFromCamera( new THREE.Vector2(0, 0), camera );
                const intersects = raycaster.intersectObjects(scene.children);
                
                let hoveringHotspot = false;
                if(intersects.length > 0) {
                    if(intersects[0].object.userData.type === 'hotspot' && intersects[0].distance < 5) {
                        hoveringHotspot = true;
                    }
                    if(intersects[0].object.userData.type === 'exit' && exitMesh.visible && intersects[0].distance < 5) {
                        hoveringHotspot = true;
                        interactMsg.innerText = "Click para SALIR";
                    } else {
                        interactMsg.innerText = "Click para interactuar (+)";
                    }
                }

                interactMsg.style.opacity = hoveringHotspot ? 1 : 0;
            }

            // Animar hotspots
            hotspots.forEach(h => {
                const scale = 1 + Math.sin(time * 0.003) * 0.2;
                h.scale.set(scale, scale, scale);
            });

            prevTime = time;
            renderer.render(scene, camera);
        }

    </script>
</body>
</html>